<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>导航 &mdash; selenium-python-docs-zh 2.53.0 文档</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.53.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="selenium-python-docs-zh 2.53.0 文档" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>导航<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>你用WebDriver要做的第一件事就是指定一个链接，一般我们使用`get`方法：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">driver.get(&quot;http://www.google.com&quot;)</span>
<span class="pre">`</span></code>
WebDriver会等待页面完全加载完(就是`onload`函数被触发了),才把程序的控制权交给你的测试或者脚本。
但是如果你的页面用了太多的AJAX，那么这个机制就没什么卵用了，因为它不知道页面到底是什么时候加载完。如果你需要确定页面完全加载完了，你可以使用`waits`</p>
<p>## 页面交互
我们比较喜欢做的事情就是和页面交互，准确的说，是和页面里的HTML元素交互。首先，我们要找到一个元素，WebDrive提供了许多方法查找元素，例如，给定一个这样的元素：
<code class="docutils literal"><span class="pre">`html</span>
<span class="pre">&lt;input</span> <span class="pre">type=&quot;text&quot;</span> <span class="pre">name=&quot;passwd&quot;</span> <span class="pre">id=&quot;passwd-id&quot;</span> <span class="pre">/&gt;</span>
<span class="pre">`</span></code>
你可以用下列任意方法找到它：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">element</span> <span class="pre">=</span> <span class="pre">driver.find_element_by_id(&quot;passwd-id&quot;)</span>
<span class="pre">element</span> <span class="pre">=</span> <span class="pre">driver.find_element_by_name(&quot;passwd&quot;)</span>
<span class="pre">element</span> <span class="pre">=</span> <span class="pre">driver.find_element_by_xpath(&quot;//input[&#64;id='passwd-id']&quot;)</span>
<span class="pre">`</span></code>
你也可以通过文本信息来找到一个链接，但是要注意，文本必须要完全匹配。
在使用`XPATH`的时候也要注意，如果有多个元素匹配，只会返回第一个。如果匹配不到任何元素，会抛出一个`NoSuchElementException`异常。</p>
<p>WebDriver有一个 基于对象的 API，我们可以通过同一个接口代表所有类型的元素，这意味着当你敲击你IDE的自动补全组合键的时候，虽然你会看到你可以调用很多方法，但不是所有的方法都行得通。不过不要担心！WebDriver会自己尝试做正确的选择。并且如果你调用一个没用的方法(例如在一个`meta`标签上调用`setSelected()`),WebDriver会抛出一个异常</p>
<p>那么，当你获取到一个元素之后，你可以做些什么呢？首先，你可能会想输入一些文本到一个文本区域:
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">element.send_keys(&quot;some</span> <span class="pre">text&quot;)</span>
<span class="pre">`</span></code>
你可以使用`Keys`类来模拟输入方向键:
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">element.send_keys(&quot;</span> <span class="pre">and</span> <span class="pre">some&quot;,</span> <span class="pre">Keys.ARROW_DOWN)</span>
<span class="pre">`</span></code>
理论上任意的元素都可以调用`send_keys`方法,就是说我们可以测试例如Gmail的键盘快捷键。
<cite>send_keys`的副作用就是输入文本到文本域不会自动清除，而是会附加到原有的文本后面，我们可以使用`clear`方法来很方便的清除文本框或者文本域的内容:
```python
element.clear()
``</cite></p>
<p>## 填充表单
我们已经知道怎么向一个文本框和文本域输入内容，但是其他元素我们要怎么处理？
你可以触发下拉选框，并且用`setSelected`方法来让一个选项被选中，处理`选择框`不会很困难:
<a href="#id2"><span class="problematic" id="id3">``</span></a><a href="#id4"><span class="problematic" id="id5">`</span></a>python
element = driver.find_element_by_xpath(&#8220;//select[&#64;name=&#8217;name&#8217;]&#8221;)
all_options = element.find_elements_by_tag_name(&#8220;option&#8221;)
for option in all_options:</p>
<blockquote>
<div>print(&#8220;Value is: %s&#8221;) % option.get_attribute(&#8220;value&#8221;)
option.click()</div></blockquote>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a>`
这段代码会找到页面的第一个选择框元素，然后遍历每个选项，输出他们的值，并且依次选中。</p>
<p>你可以看到，这种方式处理选择框不太高效，WebDriver支持许多类，其中包括一个`Select`的类，给我们提供了许多有用的方法：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">from</span> <span class="pre">selenium.webdriver.support.ui</span> <span class="pre">import</span> <span class="pre">Select</span>
<span class="pre">select</span> <span class="pre">=</span> <span class="pre">Select(driver.find_element_by_name('name'))</span>
<span class="pre">select.selct_by_index(index)</span>
<span class="pre">select.select_by_visible_text(&quot;text&quot;)</span>
<span class="pre">select.select_by_value(value)</span>
<span class="pre">`</span></code>
WebDriver 也提供了取消选中选项的方法：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">select</span> <span class="pre">=</span> <span class="pre">Select(driver.find_element_by_id('id'))</span>
<span class="pre">select.deselect_all()</span>
<span class="pre">`</span></code>
上面的代码会取消页面第一个选择框的所有选中项。</p>
<p>假设测试中，我们需要所有默认选中项的列表，<cite>Select`类提供了一个属性:
```python
select = Select(driver.find_element_by_xpath(&#8220;xpath&#8221;))
all_selected_options = select.all_selected.options
``</cite>
获取所有可用的选项：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">options</span> <span class="pre">=</span> <span class="pre">select.options</span>
<span class="pre">`</span></code></p>
<p>一旦你填写完表单，一般就要提交表单，一个方法是找到提交按钮然后点击它：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Assume</span> <span class="pre">the</span> <span class="pre">button</span> <span class="pre">has</span> <span class="pre">the</span> <span class="pre">ID</span> <span class="pre">&quot;submit&quot;</span> <span class="pre">:)</span>
<span class="pre">driver.find_element_by_id(&quot;submit&quot;).click()</span>
<span class="pre">`</span></code></p>
<p>WebDriver 对每个元素都提供一个`submit`方法，如果在一个表单内的元素上调用，WebDriver会沿着DOM树往上一直寻找，直到找到一个闭合的表单为止，然后调用`submit`方法；如果元素不在表单内，那么会抛出一个`NoSuchElementException`异常。</p>
<p>## 拖放
你可以使用拖放功能，移动确定数量的元素，或者拖到另一个元素上面：
<a href="#id8"><span class="problematic" id="id9">``</span></a><a href="#id10"><span class="problematic" id="id11">`</span></a>python
element = driver.find_element_by_name(&#8220;source&#8221;)
target = driver.find_element_by_name(&#8220;target&#8221;)</p>
<p>from selenium.webdriver import ActionChains
action_chains = ActionChains(driver)
action_chains.drag_and_drop(element,target).perform()
<a href="#id12"><span class="problematic" id="id13">``</span></a>`
可以看这个页面的[演示](<a class="reference external" href="http://www.w3schools.com/html/html5_draganddrop.asp">http://www.w3schools.com/html/html5_draganddrop.asp</a>)</p>
<p>## 在窗口(window)和框架(frame)间移动
现在的网页应用里没有页面框架或者只用一个窗口就包含了所有内容的已经很少了。WebDriver 支持在指定的窗口间移动，方法为`switch_to_window`：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">driver.switch_to_window(&quot;windowName&quot;)</span>
<span class="pre">`</span></code>
现在所有的driver的调用都会指向这个给定的窗口，但是我们怎么知道窗口的名字是什么呢？Take a look at the javascript or link that opened it:
<code class="docutils literal"><span class="pre">`html</span>
<span class="pre">&lt;a</span> <span class="pre">href=&quot;somewhere.html&quot;</span> <span class="pre">target=&quot;windowName&quot;&gt;Click</span> <span class="pre">here</span> <span class="pre">to</span> <span class="pre">open</span> <span class="pre">a</span> <span class="pre">new</span> <span class="pre">window&lt;/a&gt;</span>
<span class="pre">`</span></code>
或者，你可以传一个`window handle`给`switch_to_window()`方法,它就可以像这样迭代每一个打开的窗口:
<a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>python
for handle in driver.window_handles:</p>
<blockquote>
<div>driver.switch_to_window(handle)</div></blockquote>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">你也可以在框架和框架之间切换</span> <span class="pre">(or</span> <span class="pre">into</span> <span class="pre">iframes):</span>
<span class="pre">```python</span>
<span class="pre">driver.switch_to_frame(&quot;frameName&quot;)</span>
<span class="pre">`</span></code>
我们可以用`.`分离路径来访问子框架，并且可以指定它的索引:
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">driver.switch_to_frame(&quot;frameName.0.child&quot;)</span>
<span class="pre">`</span></code>
这会跳到&#8217;frameName&#8217;框架内第一个名为&#8217;child&#8217;的子框架。All frames are evaluated as if from <em>top</em>.</p>
<p>一旦我们操作完了框架，我们可以通过下面的操作回到父框架：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">driver.switch_to_default_content()</span>
<span class="pre">`</span></code></p>
<p>## 弹出对话框
Selenium内置支持处理弹出对话框，当你触发了弹框操作，你可以用下面的方法获得对话框元素：
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">alert</span> <span class="pre">=</span> <span class="pre">driver.switch_to_alert()</span>
<span class="pre">`</span></code>
上述代码返回当前打开的对话框对象，有了这个对象 我们可以做确定、忽略、阅读提示文本或者甚至输入prompt,这个接口可以很好的操作alerts、confirms、prompts等对话框。更多内容参阅API文档</p>
<p>## 导航：历史记录和定位
前面我们可以使用get命令（<cite>driver.get(&#8220;http://www.example.com&#8221;)</cite>）导航到一个页面。如你所见，WebDriver有一些较小的，侧重任务的接口，导航是一个很有用的任务，要打开一个页面，你可以使用`get`方法:
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">driver.get(&quot;http://www.example.com&quot;)</span>
<span class="pre">`</span></code>
要在浏览器的历史记录的后退或者前进:
<code class="docutils literal"><span class="pre">`python</span>
<span class="pre">driver.forward()</span>
<span class="pre">driver.back()</span>
<span class="pre">`</span></code>
要记得这些函数完全依赖于底层驱动，如果你过去习惯某一个浏览器的运行状态，当切换到新的浏览器时，调用这些方法有可能会出现预料之外的情况。</p>
<p>## Cookies
Before we leave these next steps。你可能会好奇如何使用cookie，首先你需要处在一个域名下，然后这样设置cookie:
<a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a>python
# Go to the correct domain
driver.get(&#8220;<a class="reference external" href="http://example.com">http://example.com</a>&#8221;)</p>
<p># Now set the cookie. This one&#8217;s valid for the entire domain
cookie = {&#8216;name&#8217;:&#8217;foo&#8217;,&#8217;value&#8217;:&#8217;bar&#8217;}
driver.add_cookie(cookie)</p>
<p># And now output all the available cookies for the current URL
driver.get_cookies()
<a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a></p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/导航.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, delong.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/导航.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>